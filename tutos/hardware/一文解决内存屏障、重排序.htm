<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
   - You can obtain one at http://mozilla.org/MPL/2.0/. -->
<!DOCTYPE html>
<html platform="win"><head>
  <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'">
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="viewport" content="width=device-width; user-scalable=0">
  <link rel="stylesheet" href="chrome://global/skin/aboutReader.css" type="text/css">
  <link rel="stylesheet" href="chrome://global/skin/aboutReaderPocket.css" type="text/css">
<link rel="stylesheet" href="chrome://global/skin/narrate.css"><title>一文解决内存屏障 - 简书</title><link rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAICAAAAEAIACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAABILAAASCwAAAAAAAAAAAAAAAAAASWTtHEhh5qZIYObmSGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDm5khh5qZJZO0cAAAAAElk7RxIYeXtSGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hh5e1JZO0cSGHmpkhg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hh5qZIYObmSGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDm5khg5f9IYOX/SGDl/0hg5f9IYOX/ipnu/5qn8P9qfen/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/TWTl/5qn8P+grfH/nKnx/3iJ6/9JYeX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f/Cyvb///////T2/f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f99juz//////////////////////8vS9/9LY+X/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/8LK9v///////f3+/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/2l96f+hrfH/o6/x/9HX+P///////////5Gg7/9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/wsr2///////9/f7/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/Vmzn////////////usP1/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f/Cyvb///////39/v9IYOX/SGDl/46d7v/+/v7//v7+//7+/v/+/v7//v7+//7+/v/+/v7/8fP9/8LK9v9keOn/SGDl/0hg5f9JYeX///////////+9xvX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/8LK9v///////f3+/0hg5f9IYOX/j53v////////////ydD3/6ax8v+msfL/prHy/6248//t8Pz//////+/x/P9dcuj/SGDl/0lh5f///////////73G9f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/wsr2///////9/f7/SGDl/0hg5f+Pne////////////+RoO//SGDl/0hg5f9IYOX/SGDl/5Kg7////////////56q8f9IYOX/SWHl////////////vcb1/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f/Cyvb///////39/v9IYOX/SGDl/4+d7////////////5Oh7/9JYeX/SWHl/0lh5f9JYeX/h5fu////////////ucL1/0hg5f9JYeX///////////+9xvX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/8LK9v///////f3+/0hg5f9IYOX/j53v//////////////////////////////////////////////////////+4wfX/SGDl/0lh5f///////////73G9f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/wsr2///////9/f7/SGDl/0hg5f+Pne/////////////g5Pr/xs32/8bN9v/Gzfb/xs32/9jd+f///////////7fB9P9IYOX/SWHl////////////vcb1/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f/Cyvb///////39/v9IYOX/SGDl/4+d7////////////5uo8P9IYOX/SGDl/0hg5f9IYOX/gZHt////////////t8D0/0hg5f9JYeX///////////+9xvX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/8LK9v///////f3+/0hg5f9IYOX/j53v////////////m6jw/0hg5f9IYOX/SGDl/0hg5f+Bke3///////////+2wPT/SGDl/0lh5f///////////73G9f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/wsr2///////9/f7/SGDl/0hg5f+Pne///////////////////////////////////////////////////////7W/9P9IYOX/SWHl////////////vcb1/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f/Cyvb///////39/v9IYOX/SGDl/4WV7f/l6Pv/5ej7/+Xo+//l6Pv/5ej7/+Xo+//l6Pv/5ej7/+Xo+//l6Pv/pbHy/0hg5f9JYeX///////////+9xvX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/2h86f96i+z/eozs/7S+9P/K0ff/p7Ly/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0lh5f///////////73G9f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9gdej///////////+8xfX/bYDq/5il8P+YpfD/mKXw/5il8P+YpfD/mKXw/5il8P+YpfD/mKXw/5il8P+YpfD/mafw////////////vcb1/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/7zF9f//////9fb9/1906P/P1fj///////////////////////////////////////////////////////////////////////////+9xvX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/oK3x/1Rq5v9/kOz///////z9/v99juz/SGDl/6u28//AyPb/wMj2/8DI9v/K0ff/4eX6/8DI9v/AyPb/wMj2/8DI9v/AyPb/wMj2/8DI9v/AyPb/wMj2/5Wj8P9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f/8/f7/9fb9/6248/9Uaub/TWTl/0hg5f9/kOz/6Ov7/+Hl+v9ccuf/SGDl/3WH6///////vMX1/1Fo5v9IYOX/SGDl/0hg5f/L0vf/9/j9/8TL9v9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/6Ov8f/6+/7//////87U+P9PZub/SGDl/7rD9f//////9fb9/05l5f9IYOX/YXXo/+7w/P//////3eL6/1lu5/9IYOX/TWTl//f4/f//////rbjz/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/22A6v/09v3//////9fc+f+Zp/D/9vf9///////Y3fn/j53v/5Si7/+Wo/D/Znrp/93i+v//////3uL6/5mn8P+yvPT///////////+yvPT/mafw/5mn8P96i+z/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/32O7P////////////////////////////////////////////////+cqfH/X3To//r7/v////////////////////////////////////////////Hz/f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/8zT9////////////2l86f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/usP1////////////iJju/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/jJvu////////////kZ/v/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9/kOz///////////+eqvH/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5uZIYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9KYeX/SmHl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYObmSGHmpkhg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hh5qZJZO0cSGHl7Uhg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYeXtSWTtHAAAAABJZO0cSGHmpkhg5uZIYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYOX/SGDl/0hg5f9IYObmSGHmpklk7RwAAAAAgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAE="></head>

<body class="light sans-serif loaded" style="--font-size: 20px; --content-width: 30em;">
  <div class="top-anchor"></div>

  <div id="toolbar" class="toolbar-container scrolled">
    <div class="toolbar reader-toolbar">
      <div class="reader-controls" articledir="ltr">
        <button class="close-button button " data-telemetry-id="reader-close" aria-label="关闭阅读模式"><span class="hover-label">关闭阅读模式</span></button>
        <ul class="dropdown style-dropdown">
          <li>
            <button class="dropdown-toggle button style-button" data-telemetry-id="reader-type-controls" aria-label="字体调整"><span class="hover-label">字体调整</span></button>
          </li>
          <li class="dropdown-popup">
            <div class="dropdown-arrow"></div>
            <div class="font-type-buttons radiorow"><input id="radio-itemsans-serif-button" type="radio" class="radio-button" name="font-type" checked="checked"><label for="radio-itemsans-serif-button" class="sans-serif-button" checked="true">无衬线</label><input id="radio-itemserif-button" type="radio" class="radio-button" name="font-type"><label for="radio-itemserif-button" class="serif-button">衬线</label></div>
            <div class="font-size-buttons buttonrow">
              <button class="minus-button" title="缩小文字"></button>
              <span class="font-size-value">5</span>
              <button class="plus-button" title="增大文字">
            </button></div>
            <div class="content-width-buttons buttonrow">
               <button class="content-width-minus-button" title="缩小内容宽度"></button>
               <span class="content-width-value">3</span>
               <button class="content-width-plus-button" title="放大内容宽度">
            </button></div>
            <div class="line-height-buttons buttonrow">
                <button class="line-height-minus-button" title="缩小行距"></button>
                <span class="line-height-value">4</span>
                <button class="line-height-plus-button" title="放大行距">
            </button></div>
            <div class="color-scheme-buttons radiorow"><input id="radio-itemlight-button" type="radio" class="radio-button" name="color-scheme" checked="checked"><label for="radio-itemlight-button" class="light-button" checked="true" title="浅色模式">浅色</label><input id="radio-itemdark-button" type="radio" class="radio-button" name="color-scheme"><label for="radio-itemdark-button" class="dark-button" title="深色模式">深色</label><input id="radio-itemsepia-button" type="radio" class="radio-button" name="color-scheme"><label for="radio-itemsepia-button" class="sepia-button" title="纸墨模式">纸墨</label></div>
          </li>
        </ul>
      <ul class="dropdown narrate-dropdown"><li><button class="dropdown-toggle button narrate-toggle" data-telemetry-id="reader-listen" aria-label="聆听"><span class="hover-label">聆听</span></button></li><li class="dropdown-popup"><div class="narrate-row narrate-control"><button class="narrate-skip-previous" disabled="disabled" title="后退"></button><button class="narrate-start-stop" title="开始"></button><button class="narrate-skip-next" disabled="disabled" title="前进"></button></div><div class="narrate-row narrate-rate"><input class="narrate-rate-input" value="0" step="5" max="100" min="-100" type="range" title="速度"></div><div class="narrate-row narrate-voices"><div class="voiceselect voice-select"><button class="select-toggle" aria-controls="voice-options">
      <span class="label">语音：</span> <span class="current-voice">默认</span>
    </button>
    <div class="options" id="voice-options" role="listbox"><button data-value="automatic" class="option selected" tabindex="-1" role="option" aria-selected="true">默认</button><button data-value="urn:moz-tts:sapi:Microsoft Lili - Chinese (China)?zh-CN" class="option" tabindex="-1" role="option">Microsoft Lili - Chinese (China)</button></div></div></div><div class="dropdown-arrow"></div></li></ul><button data-buttonid="pocket-button" data-telemetry-id="reader-save-to-pocket" class="button pocket-button" aria-label="保存到 Pocket" style="background-image: url(&quot;chrome://global/skin/icons/pocket.svg&quot;); background-size: 16px 16px;"><span class="hover-label">保存到 Pocket</span></button></div>
    </div>
  </div>

  <div class="container" style="--line-height: 1.6em;" dir="ltr">
    <div class="header reader-header reader-show-element">
      <a class="domain reader-domain" href="https://www.jianshu.com/p/64240319ed60">jianshu.com</a>
      <div class="domain-border"></div>
      <h1 class="reader-title">一文解决内存屏障 - 简书</h1>
      <div class="credits reader-credits"></div>
      <div class="meta-data">
        <div class="reader-estimated-time" dir="ltr">41-52 分钟</div>
      </div>
    </div>

    <hr>

    <div class="content">
      <div class="moz-reader-content reader-show-element"><div id="readability-page-1" class="page"><article><p>内存屏障是硬件之上、操作系统或JVM之下，对并发作出的最后一层支持。再向下是是硬件提供的支持；向上是操作系统或JVM对内存屏障作出的各种封装。内存屏障是一种标准，各厂商可能采用不同的实现。</p>
<p>本文仅为了帮助理解JVM提供的并发机制。首先，从volatile的语义引出可见性与重排序问题；接下来，阐述问题的产生原理，了解为什么需要内
存屏障；然后，浅谈内存屏障的标准、厂商对内存屏障的支持，并以volatile为例讨论内存屏障如何解决这些问题；最后，补充介绍JVM在内存屏障之上
作出的几个封装。为了帮助理解，会简要讨论硬件架构层面的一些基本原理（特别是CPU架构），但不会深入实现机制。</p>
<blockquote>
<p>内存屏障的实现涉及大量硬件架构层面的知识，又需要操作系统或JVM的配合才能发挥威力，单纯从任何一个层面都无法理解。本文整合了这三个层面的大量知识，篇幅较长，希望能在一篇文章内，把内存屏障的基本问题讲述清楚。</p>
<p>如有疏漏，还望指正！</p>
</blockquote>
<h2>volatile变量规则</h2>
<p>一个用于引出内存屏障的好例子是<code>volatile变量规则</code>。</p>
<p>volatile关键字可参考猴子刚开博客时的文章<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2016%2F11%2F29%2Fvolatile%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597%25E7%259A%2584%25E4%25BD%259C%25E7%2594%25A8%25E3%2580%2581%25E5%258E%259F%25E7%2590%2586%2F" target="_self" rel="nofollow">volatile关键字的作用、原理</a>。volatile变量规则描述了volatile变量的<strong>偏序</strong>语义；这里从volatile变量规则的角度来讲解，顺便做个复习。</p>
<h2>定义</h2>
<p>volatile变量规则：<strong>对volatile变量的写入操作必须在对该变量的读操作之前执行</strong>。</p>
<p>volatile变量规则只是一种标准，要求JVM实现保证volatile变量的偏序语义。<strong>结合程序顺序规则、传递性</strong>，该偏序语义通常表现为两个作用：</p>
<ul>
<li>保持可见性</li>
<li>禁用重排序（读操作禁止重排序之后的操作，写操作禁止重排序之前的操作）</li>
</ul>
<blockquote>
<p>补充：</p>
<ul>
<li>程序顺序规则：如果程序中操作A在操作B之前，那么在线程中操作A将在操作B之前执行。</li>
<li>传递性：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。</li>
</ul>
</blockquote>
<p>后文，如果仅涉及可见性，则指明“可见性”；如果二者均涉及，则以“偏序”代称。重排序一定会带来可见性问题，因此，不会出现单独讨论重排序的场景。</p>
<h2>正确姿势</h2>
<p>之前的文章多次涉及volatile变量规则的用法。</p>
<p>简单的仅利用volatile变量规则对volatile变量本身的可见性保证：</p>
<ul>
<li>
<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2017%2F09%2F27%2F%25E9%259D%25A2%25E8%25AF%2595%25E4%25B8%25AD%25E5%258D%2595%25E4%25BE%258B%25E6%25A8%25A1%25E5%25BC%258F%25E6%259C%2589%25E5%2587%25A0%25E7%25A7%258D%25E5%2586%2599%25E6%25B3%2595%25EF%25BC%259F%2F" target="_self" rel="nofollow">面试中单例模式有几种写法？</a>：“饱汉 - 变种 3”在DCL的基础上，使用volatile修饰单例，以保证单例的可见性。</li>
</ul>
<p>复杂的利用volatile变量规则（结合了程序顺序规则、传递性）保证变量本身及周围其他变量的偏序：</p>
<ul>
<li>
<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2017%2F12%2F05%2F%25E6%25BA%2590%25E7%25A0%2581%257C%25E5%25B9%25B6%25E5%258F%2591%25E4%25B8%2580%25E6%259E%259D%25E8%258A%25B1%25E4%25B9%258BReentrantLock%25E4%25B8%258EAQS%25EF%25BC%25881%25EF%25BC%2589%25EF%25BC%259Alock%25E3%2580%2581unlock%2F" target="_self" rel="nofollow">源码|并发一枝花之ReentrantLock与AQS（1）：lock、unlock</a>：exclusiveOwnerThread借助于volatile变量state保证其相对于state的偏序。</li>
<li>
<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2017%2F10%2F24%2F%25E6%25BA%2590%25E7%25A0%2581%257C%25E5%25B9%25B6%25E5%258F%2591%25E4%25B8%2580%25E6%259E%259D%25E8%258A%25B1%25E4%25B9%258BCopyOnWriteArrayList%2F" target="_self" rel="nofollow">源码|并发一枝花之CopyOnWriteArrayList</a>：CopyOnWriteArrayList借助于volatile变量array，对外提供偏序语义。</li>
</ul>
<h2>可见性与重排序</h2>
<p>前文多次提到可见性与重排序的问题，内存屏障的存在就是为了解决这些问题。到底什么是可见性？什么是重排序？为什么会有这些问题？</p>
<h2>可见性</h2>
<h3>定义</h3>
<p>可见性的定义常见于各种并发场景中，以多线程为例：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。</p>
<p>从性能角度考虑，没有必要在修改后就立即同步修改的值——如果多次修改后才使用，那么只需要最后一次同步即可，在这之前的同步都是性能浪费。因此，实际的可见性定义要弱一些，只需要保证：<strong>当一个线程修改了线程共享变量的值，其它线程在使用前，能够得到最新的修改值</strong>。</p>
<blockquote>
<p>可见性可以认为是最弱的“<code>一致性</code>”（<code>弱一致</code>），只保证用户见到的数据是一致的，但不保证任意时刻，存储的数据都是一致的（<code>强一致</code>）。下文会讨论“缓存可见性”问题，部分文章也会称为“缓存一致性”问题。</p>
</blockquote>
<h3>问题来源</h3>
<p>一个最简单的可见性问题来自计算机内部的缓存架构：</p>
<div>
<div>

<p><img data-original-src="//upload-images.jianshu.io/upload_images/4491294-61fd9c1e75242154.png" data-original-width="460" data-original-height="308" data-original-format="image/png" data-original-filesize="12767" data-image-index="0" src="%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F_files/4491294-61fd9c1e75242154.webp"></p>
</div>
<p>image.png</p>
</div>
<p>缓存大大缩小了高速CPU与低速内存之间的差距。以三层缓存架构为例：</p>
<ul>
<li>L1 Cache最接近CPU, 容量最小（如32K、64K等）、速度最高，每个核上都有一个L1 Cache。</li>
<li>L2 Cache容量更大（如256K）、速度更低, 一般情况下，每个核上都有一个独立的L2 Cache。</li>
<li>L3 Cache最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。</li>
</ul>
<blockquote>
<p>准确地说，每个核上有两个L1 Cache, 一个存数据 L1d Cache, 一个存指令 L1i Cache。</p>
</blockquote>
<p>单核时代的一切都是那么完美。然而，多核时代出现了可见性问题。一个badcase如下：</p>
<ol>
<li>Core0与Core1命中了内存中的同一个地址，那么各自的L1 Cache会缓存同一份数据的副本。</li>
<li>最开始，Core0与Core1都在友善的读取这份数据。</li>
<li>突然，Core0要使坏了，它修改了这份数据，使得两份缓存中的数据不同了，更确切的说，Core1 L1 Cache中的数据<code>失效</code>了。</li>
</ol>
<p>单核时代只有Core0，Core0修改Core0读，没什么问题；但是，现在<em>Core0修改后，Core1并不知道数据已经失效，继续傻傻的使用</em>，轻则数据计算错误，重则导致死循环、程序崩溃等。</p>
<p>实际的可见性问题还要扩展到两个方向：</p>
<ul>
<li>除三级缓存外，<em>各厂商实现的硬件架构中还存在多种多样的缓存，都存在类似的可见性问题</em>。例如，寄存器就相当于CPU与L1 Cache之间的缓存。</li>
<li>各种高级语言（包括Java）的多线程内存模型中，<em>在线程栈内自己维护一份缓存是常见的优化措施，但显然在CPU级别的缓存可见性问题面前，一切都失效了</em>。</li>
</ul>
<blockquote>
<p>以上只是最简单的可见性问题，不涉及重排序等。</p>
<p>重排序也会导致可见性问题；同时，缓存上的可见性也会引起一些看似重排序导致的问题。</p>
</blockquote>
<h2>重排序</h2>
<h3>定义</h3>
<p>重排序并没有严格的定义。整体上可以分为两种：</p>
<ul>
<li>真·重排序：<strong>编译器、底层硬件（CPU等）出于“优化”的目的</strong>，按照某种规则将指令重新排序（尽管有时候看起来像乱序）。</li>
<li>伪·重排序：由于<strong>缓存同步顺序</strong>等问题，看起来指令被重排序了。</li>
</ul>
<p>重排序也是单核时代非常优秀的优化手段，有足够多的措施保证其在单核下的正确性。在多核时代，如果工作线程之间不共享数据或仅共享不可变数据，重排
序也是性能优化的利器。然而，如果工作线程之间共享了可变数据，由于两种重排序的结果都不是固定的，会导致工作线程似乎表现出了随机行为。</p>
<blockquote>
<p>第一次接触重排序的概念一定很迷糊，耐心，耐心。</p>
</blockquote>
<h3>问题来源</h3>
<p>重排序问题无时无刻不在发生，源自三种场景：</p>
<ol>
<li>编译器编译时的优化</li>
<li>处理器执行时的乱序优化</li>
<li>缓存同步顺序（导致可见性问题）</li>
</ol>
<p>场景1、2属于真·重排序；场景3属于伪·重排序。场景3也属于可见性问题，为保持连贯性，我们先讨论场景3。</p>
<h4>可见性导致的伪·重排序</h4>
<p>缓存同步顺序本质上是可见性问题。</p>
<p>假设<code>程序顺序</code>（program order）中先更新变量v1、再更新变量v2，不考虑真·重排序：</p>
<ol>
<li>Core0先更新缓存中的v1，再更新缓存中的v2（位于两个缓存行，这样淘汰缓存行时不会一起写回内存）。</li>
<li>Core0读取v1（假设使用LRU协议淘汰缓存）。</li>
<li>Core0的缓存满，将最远使用的v2写回内存。</li>
<li>Core1的缓存中本来存有v1，现在将v2加载入缓存。</li>
</ol>
<blockquote>
<p>重排序是针对程序顺序而言的，如果指令执行顺序与程序顺序不同，就说明这段指令被重排序了。</p>
</blockquote>
<p>此时，<em>尽管“更新v1”的事件早于“更新v2”发生，但Core1只看到了v2的最新值，却看不到v1的最新值</em>。这属于可见性导致的<strong>伪·重排序：虽然没有实际上没有重排序，但看起来发生了重排序</strong>。</p>
<p>可以看到，缓存可见性不仅仅导致可见性问题，还会导致伪·重排序。因此，<em>只要解决了缓存上的可见性问题，也就解决了伪·重排序</em>。</p>
<h5>MESI协议</h5>
<p>回到可见性问题中的例子和可见性的定义。要解决这个问题很简单，套用可见性的定义，只需要：<em>在Core0修改了数据v后，让Core1在使用v前，能得到v最新的修改值</em>。</p>
<p>这个要求很弱，既可以在每次修改v后，都同步修改值到其他缓存了v的Cache中；又可以只同步使用前的最后一次修改值。后者性能上更优，如何实现呢：</p>
<ol>
<li>Core0修改v后，发送一个信号，将Core1缓存的v标记为失效，并将修改值写回内存。</li>
<li>Core0可能会多次修改v，每次修改都只发送一个信号（发信号时会锁住缓存间的总线），Core1缓存的v保持着失效标记。</li>
<li>Core1使用v前，发现缓存中的v已经失效了，得知v已经被修改了，于是重新从其他缓存或内存中加载v。</li>
</ol>
<p>以上即是MESI（Modified Exclusive Shared Or Invalid，缓存的四种状态）协议的基本原理，不算严谨，但对于理解缓存可见性（更常见的称呼是“缓存一致性”）已经足够。</p>
<p>MESI协议解决了CPU缓存层面的可见性问题。</p>
<blockquote>
<p>以下是MESI协议的缓存状态机，简单看看即可：</p>
<div>
<div>

<p><img data-original-src="//upload-images.jianshu.io/upload_images/4491294-bce817be200cb1a4.png" data-original-width="375" data-original-height="256" data-original-format="image/png" data-original-filesize="43202" data-image-index="1" src="%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F_files/4491294-bce817be200cb1a4.webp"></p>
</div>
<p>image.png</p>
</div>
<p>状态：</p>
<ul>
<li>M（修改, Modified）: 本地处理器已经修改缓存行, 即是脏行, 它的内容与内存中的内容不一样. 并且此cache只有本地一个拷贝（专有）。</li>
<li>E（专有, Exclusive）: 缓存行内容和内存中的一样, 而且其它处理器都没有这行数据。</li>
<li>S（共享, Shared）: 缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝。</li>
<li>I（无效, Invalid）: 缓存行失效, 不能使用。</li>
</ul>
</blockquote>
<h5>剩余问题</h5>
<p>既然有了MESI协议，是不是就不需要volatile的可见性语义了？当然不是，还有三个问题：</p>
<ul>
<li>
<strong>并不是所有的硬件架构都提供了相同的一致性保证，JVM需要volatile统一语义</strong>（就算是MESI，也只解决CPU缓存层面的问题，没有涉及其他层面）。</li>
<li>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</li>
<li>如果不考虑真·重排序，MESI确实解决了CPU缓存层面的可见性问题；然而，真·重排序也会导致可见性问题。</li>
</ul>
<blockquote>
<p>暂时第一个问题称为“<code>内存可见性</code>”问题，内存屏障解决了该问题。后文讨论。</p>
</blockquote>
<h4>编译器编译时的优化</h4>
<blockquote>
<p>JVM自己维护的内存模型中也有可见性问题，使用volatile做标记，取消volatile变量的缓存，就解决了JVM层面的可见性问题。编译器产生的重排序也采用了同样的思路。</p>
</blockquote>
<p>编译器为什么要重排序（re-order）呢？和处理器乱序执行的目的是一样的：与其等待阻塞指令（如等待缓存刷入）完成，不如先去执行其他指令。与处理器乱序执行相比，编译器重排序能够完成更大范围、效果更好的乱序优化。</p>
<blockquote>
<p>由于同处理器乱序执行的目的相同，原理相似，这里不讨论编译器重排序的实现原理。</p>
</blockquote>
<p>幸运的是，既然是编译器层面的重排序，自然可以由编译器控制。使用volatile做标记，就可以禁用编译器层面的重排序。</p>
<h4>处理器执行时的乱序优化</h4>
<p>处理器层面的乱序优化节省了大量等待时间，提高了处理器的性能。</p>
<p>所谓“乱序”只是被叫做“乱序”，实际上也遵循着一定规则：只要两个指令之间不存在数据依赖，就可以对这两个指令乱序。不必关心数据依赖的精确定义，可以理解为：<strong>只要不影响程序单线程、顺序执行的结果，就可以对两个指令重排序</strong>。</p>
<blockquote>
<p>不进行乱序优化时，处理器的指令执行过程如下：</p>
<ol>
<li>指令获取。</li>
<li>如果输入的运算对象是可以获取的（比如已经存在于寄存器中），这条指令会被发送到合适的功能单元。如果一个或者更多的运算对象在当前的时钟周期中是不可获取的（通常需要从主内存获取），处理器会开始等待直到它们是可以获取的。</li>
<li>指令在合适的功能单元中被执行。</li>
<li>功能单元将运算结果写回寄存器。</li>
</ol>
<p>乱序优化下的执行过程如下：</p>
<ol>
<li>指令获取。</li>
<li>指令被发送到一个指令序列（也称<code>执行缓冲区</code>或者<code>保留站</code>）中。</li>
<li>
<strong>指令将在序列中等待，直到它的数据运算对象是可以获取的。然后，指令被允许在先进入的、旧的指令之前离开序列缓冲区</strong>。（此处表现为乱序）</li>
<li>指令被分配给一个合适的功能单元并由之执行。</li>
<li>结果被放到一个序列中。</li>
<li>仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器中。（重整乱序结果）</li>
</ol>
<p>当然，为了实现乱序优化，还需要很多技术的支持，如<code>寄存器重命名</code>、<code>分枝预测</code>等，但大致了解到这里就足够。后文的注释中会据此给出内存屏障的实现方案。</p>
</blockquote>
<p>乱序优化在单核时代不影响正确性；但多核时代的多线程能够在不同的核上实现真正的并行，一旦线程间共享数据，就出现问题了。看一段很经典的代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>OutofOrderExecution</span> <span>{</span>
    <span>private</span> <span>static</span> <span>int</span> x <span>=</span> <span>0</span><span>,</span> y <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>static</span> <span>int</span> a <span>=</span> <span>0</span><span>,</span> b <span>=</span> <span>0</span><span>;</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>
        <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                a <span>=</span> <span>1</span><span>;</span>
                x <span>=</span> b<span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                b <span>=</span> <span>1</span><span>;</span>
                y <span>=</span> a<span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        t1<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        t2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>“<span>(</span>” <span>+</span> x <span>+</span> “<span>,</span>” <span>+</span> y <span>+</span> “<span>)</span>”<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>
<p><em>不考虑编译器重排序和缓存可见性问题</em>，上面的代码可能会输出什么呢？</p>
<p>最容易想到的结果是<code>(0,1)</code>、<code>(1,0)</code>或<code>(1,1)</code>。因为可能先后执行线程t1、t2，也可能反之，还可能t1、t2交替执行。</p>
<p>然而，<em>这段代码的执行结果也可能是(0,0)</em>，看起来违反常理。这是处理器乱序执行的结果：线程t1内部的两行代码之间不存在数据依赖，因此，可以将<code>x = b</code>乱序到<code>a = 1</code>前；同时，线程t2中的<code>y = a</code>早于线程t1中的<code>a = 1</code>执行。一个可能的执行序列如下：</p>
<ol>
<li>t1: x = b</li>
<li>t2: b = 1</li>
<li>t2: y = a</li>
<li>t1: a = 1</li>
</ol>
<blockquote>
<p>这里将代码等同于指令，不严谨，但不妨碍理解。</p>
</blockquote>
<p>看起来，似乎将上述重排序（或乱序）导致的问题称为“可见性”问题也未尝不可。然而，这种重排序的危害要远远大于单纯的可见性，因为并不是所有的指令都是简单的读或者写——<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2017%2F09%2F27%2F%25E9%259D%25A2%25E8%25AF%2595%25E4%25B8%25AD%25E5%258D%2595%25E4%25BE%258B%25E6%25A8%25A1%25E5%25BC%258F%25E6%259C%2589%25E5%2587%25A0%25E7%25A7%258D%25E5%2586%2599%25E6%25B3%2595%25EF%25BC%259F%2F" target="_self" rel="nofollow">面试中单例模式有几种写法？</a>与<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2016%2F11%2F29%2Fvolatile%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597%25E7%259A%2584%25E4%25BD%259C%25E7%2594%25A8%25E3%2580%2581%25E5%258E%259F%25E7%2590%2586%2F" target="_self" rel="nofollow">volatile关键字的作用、原理</a>中都提到了<code>部分初始化</code>的例子，这种<code>不安全发布</code>就是由于重排序导致的。因此，<strong>将重排序归为“可见性”问题并不合适，只能说重排序会导致可见性问题</strong>。</p>
<p>也就是说，单纯解决内存可见性问题是不够的，还<strong>需要专门解决<code>处理器重排序</code>的问题</strong>。</p>
<blockquote>
<p>当然，某些处理器不会对指令乱序，或能够基于多核间的数据依赖乱序。这时，volatile仅用于统一重排序方面的语义。</p>
</blockquote>
<h2>内存屏障</h2>
<blockquote>
<p>内存屏障（Memory Barrier）与内存栅栏（Memory Fence）是同一个概念，不同的叫法。</p>
</blockquote>
<p>通过<strong>volatile标记，可以解决编译器层面的可见性与重排序问题</strong>。而<strong>内存屏障则解决了硬件层面的可见性与重排序问题</strong>。</p>
<blockquote>
<p>猴子暂时没有验证下述分析，仅从逻辑和系统设计考量上进行了判断、取舍。以后会补上实验。</p>
</blockquote>
<h2>标准</h2>
<p>先简单了解两个指令：</p>
<ul>
<li>Store：将处理器缓存的数据刷新到内存中。</li>
<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>
</ul>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p>
<p>然而，<strong>除了mfence，不同的CPU架构对内存屏障的实现方式与实现程度非常不一样</strong>。相对来说，Intel CPU的<code>强内存模型</code>比DEC Alpha的<code>弱复杂内存模型</code>（缓存不仅分层了，还分区了）更简单。x86架构是在多线程编程中最常见的，下面讨论x86架构中内存屏障的实现。</p>
<blockquote>
<p>查阅资料时，你会发现每篇讲内存屏障的文章讲的都不同。不过，重要的是理解基本原理，需要的时候再继续深究即可。</p>
<p>不过不管是那种方案，<strong>内存屏障的实现都要针对乱序执行的过程来设计</strong>。前文的注释中讲解了乱序执行的基本原理：核心是一个<strong>序列缓冲区</strong>，只要指令的数据运算对象是可以获取的，指令就被允许在先进入的、旧的指令之前离开序列缓冲区，开始执行。对于内存可见性的语义，内存屏障可以通过使用类似MESI协议的思路实现。对于重排序语义的实现机制，猴子没有继续研究，一种可行的思路是：</p>
<ul>
<li>当CPU收到屏障指令时，不将屏障指令放入序列缓冲区，而将屏障指令及后续所有指令放入一个FIFO队列中（指令是按批发送的，不然没有乱序的必要）</li>
<li>允许乱序执行完序列缓冲区中的所有指令</li>
<li>从FIFO队列中取出屏障指令，执行（并刷新缓存等，实现内存可见性的语义）</li>
<li>将FIFO队列中的剩余指令放入序列缓冲区</li>
<li>恢复正常的乱序执行</li>
</ul>
<p>对于x86架构中的sfence屏障指令而言，则保证sfence之前的store执行完，再执行sfence，最后执行sfence之后的store；除了禁用sfence前后store乱序带来的新的数据依赖外，不影响load命令的乱序。详细见后。</p>
</blockquote>
<h2>x86架构的内存屏障</h2>
<p>x86架构并没有实现全部的内存屏障。</p>
<h3>Store Barrier</h3>
<p>sfence指令实现了Store Barrier，相当于StoreStore Barriers。</p>
<p>强制所有在sfence指令之前的store指令，都在该sfence指令执行之前被执行，发送缓存失效信号，并把store 
buffer中的数据刷出到CPU的L1 
Cache中；所有在sfence指令之后的store指令，都在该sfence指令执行之后被执行。即，禁止对sfence指令前后store指令的重
排序跨越sfence指令，使<strong>所有Store Barrier之前发生的内存更新都是可见的</strong>。</p>
<p>这里的“可见”，指<strong>修改值可见</strong>（内存可见性）且<strong>操作结果可见</strong>（禁用重排序）。下同。</p>
<blockquote>
<p>内存屏障的标准中，讨论的是缓存与内存间的<code>相干性</code>，实际上，同样适用于寄存器与缓存、甚至寄存器与内存间等多级缓存之
间。x86架构使用了MESI协议的一个变种，由协议保证三层缓存与内存间的相关性，则内存屏障只需要保证store 
buffer（可以认为是寄存器与L1 Cache间的一层缓存）与L1 Cache间的相干性。下同。</p>
</blockquote>
<h3>Load Barrier</h3>
<p>lfence指令实现了Load Barrier，相当于LoadLoad Barriers。</p>
<p>强制所有在lfence指令之后的load指令，都在该lfence指令执行之后被执行，并且一直等到load 
buffer被该CPU读完才能执行之后的load指令（发现缓存失效后发起的刷入）。即，禁止对lfence指令前后load指令的重排序跨越
lfence指令，配合Store Barrier，使<strong>所有Store Barrier之前发生的内存更新，对Load Barrier之后的load操作都是可见的</strong>。</p>
<h3>Full Barrier</h3>
<p>mfence指令实现了Full Barrier，相当于StoreLoad Barriers。</p>
<p>mfence指令综合了sfence指令与lfence指令的作用，强制所有在mfence指令之前的store/load指令，都在该
mfence指令执行之前被执行；所有在mfence指令之后的store/load指令，都在该mfence指令执行之后被执行。即，禁止对
mfence指令前后store/load指令的重排序跨越mfence指令，使<strong>所有Full Barrier之前发生的操作，对所有Full Barrier之后的操作都是可见的。</strong></p>
<h2>volatile如何解决内存可见性与处理器重排序问题</h2>
<blockquote>
<p>在编译器层面，仅将volatile作为标记使用，取消编译层面的缓存和重排序。</p>
</blockquote>
<p>如果硬件架构本身已经保证了内存可见性（如单核处理器、一致性足够的内存模型等），那么volatile就是一个空标记，不会插入相关语义的内存屏障。</p>
<p>如果硬件架构本身不进行处理器重排序、有更强的重排序语义（能够分析多核间的数据依赖）、或在单核处理器上重排序，那么volatile就是一个空标记，不会插入相关语义的内存屏障。</p>
<p>如果不保证，仍以x86架构为例，JVM对volatile变量的处理如下：</p>
<ul>
<li>在写volatile变量v之后，插入一个sfence。这样，sfence之前的所有store（包括写v）不会被重排序到sfence之后，
sfence之后的所有store不会被重排序到sfence之前，禁用跨sfence的store重排序；且sfence之前修改的值都会被写回缓存，
并标记其他CPU中的缓存失效。</li>
<li>在读volatile变量v之前，插入一个lfence。这样，lfence之后的load（包括读v）不会被重排序到lfence之前，
lfence之前的load不会被重排序到lfence之后，禁用跨lfence的load重排序；且lfence之后，会首先刷新无效缓存，从而得到最
新的修改值，与sfence配合保证内存可见性。</li>
</ul>
<blockquote>
<p>在另外一些平台上，JVM使用mfence代替sfence与lfence，实现更强的语义。</p>
</blockquote>
<p>二者结合，共同实现了Happens-Before关系中的volatile变量规则。</p>
<h2>JVM对内存屏障作出的其他封装</h2>
<p>除volatile外，常见的JVM实现还基于内存屏障作了一些其他封装。<strong>借助于内存屏障，这些封装也得到了内存屏障在可见性与重排序上的语义</strong>。</p>
<blockquote>
<p>借助：piggyback。</p>
<p>在JVM中，借助通常指：将Happens-Before的程序顺序规则与其他某个顺序规则（通常是监视器锁规则、volatile变量规则）结合起来，从而对某个未被锁保护的变量的访问操作进行排序。</p>
<p>本文将借助的语义扩展到更大的范围，可以借助任何现有机制，以获得现有机制的某些属性。当然，并不是所有属性都能被借助，比如原子性。但基于前文对内存屏障的分析可知，可见性与重排序是可以被借助的。</p>
</blockquote>
<p>下面仍基于x86架构讨论。</p>
<h2>final关键字</h2>
<p>如果一个实例的字段被声明为final，则JVM会在初始化final变量后插入一个sfence。</p>
<blockquote>
<p>类的final字段在<code>&lt;clinit&gt;()</code>方法中初始化，其可见性由JVM的类加载过程保证。</p>
</blockquote>
<p>final字段的初始化在<code>&lt;init&gt;()</code>方法中完成。sfence禁用了sfence前后对store的重排序，且保证final字段初始化之前（include）的内存更新都是可见的。</p>
<h3>再谈部分初始化</h3>
<p>上述良好性质被称为“<code>初始化安全性</code>”。它保证，<strong>对于被正确构造的对象，所有线程都能看到构造函数给对象的各个final字段设置的正确值，而不管采用何种方式来发布对象</strong>。</p>
<blockquote>
<p><strong>这里将可见性从“final字段初始化之前（include）的内存更新”缩小到“final字段初始化”</strong>。猴子没找到确切的原因，手里暂时只有一个jdk也不方便验证。可能是因为，<em>JVM没有要求虚拟机实现在生成<code>&lt;init&gt;()</code>方法时编排字段初始化指令的顺序</em>。</p>
</blockquote>
<p>初始化安全性为解决部分初始化问题带来了新的思路：如果待发布对象的所有域都是final修饰的，那么可以防止对对象的初始引用被重排序到构造过程完成之前。于是，<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmonkeysayhi.github.io%2F2017%2F09%2F27%2F%25E9%259D%25A2%25E8%25AF%2595%25E4%25B8%25AD%25E5%258D%2595%25E4%25BE%258B%25E6%25A8%25A1%25E5%25BC%258F%25E6%259C%2589%25E5%2587%25A0%25E7%25A7%258D%25E5%2586%2599%25E6%25B3%2595%25EF%25BC%259F%2F" target="_self" rel="nofollow">面试中单例模式有几种写法？</a>中的饱汉变种三还可以扔掉volatile，改为借助final的sfence语义：</p>
<div><pre><code><span>// 饱汉</span>
<span>// ThreadSafe</span>
<span>public</span> <span>class</span> <span>Singleton1_3</span> <span>{</span>
  <span>private</span> <span>static</span> <span>Singleton1_3</span> singleton <span>=</span> <span>null</span><span>;</span>
  
  <span>public</span> <span>int</span> f1 <span>=</span> <span>1</span><span>;</span>   <span>// 触发部分初始化问题</span>
  <span>public</span> <span>int</span> f2 <span>=</span> <span>2</span><span>;</span>

  <span>private</span> <span>Singleton1_3</span><span>(</span><span>)</span> <span>{</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>Singleton1_3</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>
      <span>synchronized</span> <span>(</span><span>Singleton1_3</span><span>.</span><span>class</span><span>)</span> <span>{</span>
        <span>// must be a complete instance</span>
        <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>
          singleton <span>=</span> <span>new</span> <span>Singleton1_3</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> singleton<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<blockquote>
<p>注意，初始化安全性仅针对安全发布中的部分初始化问题，与其他安全发布问题、发布后的可见性问题无关。</p>
</blockquote>
<h2>CAS</h2>
<p>在x86架构上，CAS被翻译为"<code>lock cmpxchg...</code>"。cmpxchg是CAS的汇编指令。在CPU架构中依靠lock信号保证可见性并禁止重排序。</p>
<p>lock前缀是一个特殊的信号，执行过程如下：</p>
<ul>
<li>对总线和缓存上锁。</li>
<li>强制所有lock信号之前的指令，都在此之前被执行，并同步相关缓存。</li>
<li>执行lock后的指令（如cmpxchg）。</li>
<li>释放对总线和缓存上的锁。</li>
<li>强制所有lock信号之后的指令，都在此之后被执行，并同步相关缓存。</li>
</ul>
<p>因此，lock信号虽然不是内存屏障，但具有mfence的语义（当然，还有<code>排他性</code>的语义）。</p>
<p>与内存屏障相比，lock信号要额外对总线和缓存上锁，成本更高。</p>
<h2>锁</h2>
<p>JVM的内置锁通过操作系统的管程实现。且不论管程的实现原理，由于管程是一种互斥资源，修改互斥资源至少需要一个CAS操作。因此，锁必然也使用了lock信号，具有mfence的语义。</p>
<p>锁的mfence语义实现了Happens-Before关系中的监视器锁规则。</p>
<blockquote>
<p>CAS具有同样的mfence语义，也必然具有与锁相同的偏序关系。尽管JVM没有对此作出显式的要求。</p>
</blockquote>
<hr>
<blockquote>
<p>参考:</p>
<ul>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fifeve.com%2Fjava-context-switch%2F" target="_self" rel="nofollow">从Java视角理解系统结构(一)CPU上下文切换</a></li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fifeve.com%2Ffrom-javaeye-cpu-cache%2F" target="_self" rel="nofollow">从Java视角理解系统结构（二）CPU缓存</a></li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fifeve.com%2Ffrom-javaeye-false-sharing%2F" target="_self" rel="nofollow">从Java视角理解系统结构（三）伪共享</a></li>
<li><a href="https://www.jianshu.com/p/506c1e38a922" target="_self">面试必问的volatile，你了解多少？</a></li>
<li><a href="https://link.jianshu.com/?t=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E4%25B9%25B1%25E5%25BA%258F%25E6%2589%25A7%25E8%25A1%258C" target="_self" rel="nofollow">乱序执行</a></li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fgjq_1988%2Farticle%2Fdetails%2F39520729" target="_self" rel="nofollow">（转）CPU乱序执行原理</a></li>
<li><a href="https://link.jianshu.com/?t=https%3A%2F%2Ftech.meituan.com%2Fjava-memory-reordering.html" target="_self" rel="nofollow">Java内存访问重排序的研究</a></li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fdd864140130%2Farticle%2Fdetails%2F56494925" target="_self" rel="nofollow">谈乱序执行和内存屏障</a></li>
<li>
<a href="https://link.jianshu.com/?t=http%3A%2F%2Fifeve.com%2Fmemory-barriers-or-fences%2F" target="_self" rel="nofollow">内存屏障</a>（阅读本文的原文需要翻墙，这里给出一篇译文的地址）</li>
<li><a href="https://link.jianshu.com/?t=http%3A%2F%2F0xffffff.org%2F2017%2F02%2F21%2F40-atomic-variable-mutex-and-memory-barrier%2F" target="_self" rel="nofollow">聊聊原子变量、锁、内存屏障那点事</a></li>
<li><a href="https://link.jianshu.com/?t=%25E8%2581%258A%25E8%2581%258A%25E9%25AB%2598%25E5%25B9%25B6%25E5%258F%2591%25EF%25BC%2588%25E4%25B8%2589%25E5%258D%2581%25E4%25BA%2594%25EF%25BC%2589Java%25E5%2586%2585%25E5%25AD%2598%25E6%25A8%25A1%25E5%259E%258B%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25EF%25BC%2588%25E4%25B8%2589%25EF%25BC%2589%25E7%2590%2586%25E8%25A7%25A3%25E5%2586%2585%25E5%25AD%2598%25E5%25B1%258F%25E9%259A%259C" target="_self" rel="nofollow">聊聊高并发（三十五）Java内存模型那些事（三）理解内存屏障</a></li>
</ul>
</blockquote>


</article></div></div>
    </div>

    <div>
      <div class="reader-message"></div>
    </div>
    <div aria-owns="toolbar"></div>
  </div>

  <div id="pocket-cta-container" hidden="">
    <div class="pocket-cta-inner" id="pocket-cta-only">
      <div class="pocket-cta">
        <header class="pocket-cta-header">Save anything from across the web in Pocket, your personal library.</header>
        <p class="pocket-cta-subhead">As part of the Firefox family, 
Pocket provides a quiet, calm space that’s perfect for reading. It 
strips away all the distractions of the internet so you can really 
focus.</p>
        <a href="https://getpocket.com/signup?utm_source=firefox_reader&amp;utm_medium=variant_cta_only" class="pocket-btn pocket-sign-up"><strong>Sign up</strong> - it’s free</a>
        <a href="https://getpocket.com/explore?utm_source=firefox_reader&amp;utm_medium=variant_cta_only" class="pocket-btn pocket-discover-more"><strong>Discover more</strong></a>
      </div>
      <button class="pocket-dismiss-cta" title="Dismiss"></button>
    </div>

    <div class="pocket-cta-inner" id="pocket-cta-and-recs">
      <div class="pocket-recs-top">
        <div class="col">
          <header class="pocket-cta-header">Discover the most thought-provoking stories out there, curated by Pocket.</header>
          <p class="pocket-cta-subhead">As part of the Firefox family, 
Pocket surfaces the best articles out there—new perspectives, intriguing
 deep-dives, timeless classics—and we do this with the same dedication 
to privacy you’ve come to expect from Firefox and Mozilla. </p>
        </div>
        <div class="col">
          <button class="pocket-collapse-recs"></button>
        </div>
      </div>

      <div class="pocket-recs"></div>

      <div class="pocket-sign-up-wrapper">
        <a href="https://getpocket.com/explore?utm_source=firefox_reader&amp;utm_medium=variant_cta_plus_recs" class="pocket-btn pocket-sign-up"><strong>Discover more</strong></a>
      </div>
    </div>
  </div>



</body></html>