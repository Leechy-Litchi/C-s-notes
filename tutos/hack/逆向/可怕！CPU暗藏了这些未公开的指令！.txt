https://mp.weixin.qq.com/s/4bPTnHYAQGjr2oMHjMmfEA
这份PDF内容是2017年顶级黑客大会Black Hat上的一篇报告：《us-17-Domas-Breaking-The-x86-ISA》，作者是大神：@xoreaxeaxeax


我们以单字节指令为例，单字节的范围是0x00-0XFF，总共256种组合，Intel的指令手册中是这样介绍单字节指令的：
横向为单字节的高四位，纵向为单字节的低四位，顺着表格定位，可以找到每一个单字节指令的定义。比如我们常见的nop指令的机器码是0x90，就是行为9，列为0的那一格。

但是不知道你发现没有，这张表格中还有些单元格是空的，比如0xF1，那CPU拿到一个为0xF1的指令，会怎么执行呢？


有单字节指令，比如：

    90  nop
    CC  int 3
    C3  ret

也有双字节指令，比如：

    8B C8  mov ecx,eax
    6A 20  push 20h

还有三四节、四字节、五字节・・・最长能有十几个字节，比如这条指令：

    指令：lock add qword cs:[eax + 4 * eax + 07e06df23h], 0efcdab89h
    机器码：2e 67 f0 48 818480 23df067e 89abcdef

一个字节、两个字节，甚至三个四个遍历都还能接受，4个字节最多也就42亿多种组合，对于计算机来说，也还能接受。

但越往后，容量是呈指数型增长，这种情况再去遍历，显然是不现实的。

这份报告中提出了一种深度优先的搜索算法：

比如压栈的指令push，下面几条虽然字节序列不同，但变化的只是数据，其实都是压栈指令，对于这类指令，就没必要花费时间去遍历：

        68 6F 72 6C 64    push 646C726Fh
        68 6F 2C 20 77    push 77202C6Fh
        68 68 65 6C 6C    push 6C6C6568h

第一个字节68就是关键字节，后面的四个字节都是压入栈中的数据，就属于无关紧要的字节。

如果能识别出这类，快速跳过，将能够大面积减少需要遍历的搜索空间。



如何判定指令长度

当CPU发现指令位于不可执行的页面中时，它会抛异常！

现在，在内存中这样放置可执行和不可执行的页：第一个字节放在第一个页面的末尾位置，后面在字节放在第二个不可执行的页面上。

然后JMP到这条指令的地址，尝试去执行它，CPU中的译码器开始译码：

译码器译码发现是0F，不是单字节指令，还需要继续分析后面的字节，继续取第二个字节：

但注意，第二个字节是位于不可执行的页面，CPU检查发现后会抛出页错误异常：

继续上面这个过程

当放了四个字节在可执行页面之后，事情发生了变化：

指令可以执行了！虽然也抛了异常（因为天知道这是个什么指令，会抛什么异常），但页错误的地址不再是第二个页面的地址了！

