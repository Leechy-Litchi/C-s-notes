https://www.bilibili.com/video/BV1jv411q7cS
10:10

mov [r14],(float)7000
movss [r14],xmm3
//xmm0到7都可

二者类似，注意前者不能用movss，因为movss需要用xmm浮点寄存器，而mov不能用但可以让位数相同或小于的数据存入地址



https://bbs.pediy.com/thread-216486.htm
SSE C Streaming SIMD Extension，是Intel从PIII开始加入的一种x86扩展指令集。
在SSE以前，x86的浮点运算都是以栈式FPU完成的，有一定x86汇编经验的人应该不会对那些复杂的fld、fst指令陌生吧。
而SSE一方面让浮点运算可以像整数运算的模式、如 add eax , ebx 那样通过直接访问寄存器完成，绕开了讨厌的栈，另一方面引入了SIMD这个概念。
SIMD C Single Instruction Multiply Data，顾名思义，它可以同时让一条指令在多个数据上执行，这种体系结构在一度在大型机上非常流行，需要经常进行海量运算的大型机器通常会通过一个数学SIMD虚拟机加快处理速度，比如同时让一组数据执行一个变换，数据的规模有上百万之巨，而SIMD则可以优化数据的存储与运算，减免某些切换Context的开销。


https://www.zhihu.com/question/539942499/answer/2546487423

movss/movsd qword ptr ss:[eax],xmm0
从xmm寄存器里读取一个单/双精度浮点数写入到地址或xmm寄存器里

