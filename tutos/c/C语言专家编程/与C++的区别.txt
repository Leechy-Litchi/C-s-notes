1. C语言允许用户定义新的类型(struct, enum)来支持抽象，但C语言不允许在用户定义类型中重新定义*,<<,[],+等预定义操作符，而C++则允许。

2. C++同时提供自动和受控制的初始化、数据在生命期结束后自动消除以及隐式类型转换。这些特性有些是C语言不支持的，有些在C语言里不是很方便。(?)

3. C语言没有完备的机制来实现封装。

    封装即把数据和相关的操作捆绑在一起，具体说是把用户定义的数据结构和用户定义的能够在这些数据结构上进行操作的函数捆绑在一起实现了数据的完整性，别的函数无法访问用户定义类型的内部数据或操作。C语言允许程序员把各种数据类型组合在一起形成自定义的记录(结构体)，但无法对函数进行限制。如果一个结构是完全可见的，其任何部分都可能以任何方式被修改。人们无法把函数固定在数据类型上，使它们清晰地融为一体。

4. 类型转换

int i = 3;
float x = (float)i;  // C style
float y = float(i);  // C++ style

5. 在C语言中，一个语句块中所有的声明都必须放在所有语句的前面，在C++中声明可以出现在语句可以出现的任何地方。

6. 在C++中，一个内层作用域的结构名将会隐藏外层空间中相同的对象名，在C语言中则并非如此。

7. 在C++中字符常量的类型是char，在C语言中字符常量的类型是int。即在C++中，sizeof('a') = 1；在C语言中，sizeof('a') = 4.(假设sizeof(int) = 4)。

8. 由于C++中增加了新的注释符//，有时会在两种语言中产生微妙而怪异的差别。

9. 在C++中存在，但在C语言中却不存在的限制有：

    (1) 在C++中用户代码不能调用main()函数，在C语言中这是运行的(尽管这种情况很罕见)。

    (2) 完整的函数原型声明在C++中是必须的，在C语言中则没这么严格。

    (3) 在C++中由typedef定义的名字不能与已有的结构标签冲突，在C语言中这是允许的(它们分属不同的名字空间)。

    (4) 当void*指针赋值给另一个类型的指针时，C++规定必须进行强制类型转换，在C语言中却无必要。