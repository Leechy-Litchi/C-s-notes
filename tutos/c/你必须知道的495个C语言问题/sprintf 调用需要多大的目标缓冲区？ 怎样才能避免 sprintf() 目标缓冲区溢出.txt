当用于 sprintf() 的格式串已知且相对简单时, 你有时可以预测出缓冲区的大小。 如果格式串中包含一个或两个 %s, 你可以数出固定字符的个数再加上对插入的 字符串的 strlen() 调用的返回值。对于整形, %d 输出的字符数不会超过

	((sizeof(int) * CHAR_BIT + 2) / 3 + 1)  /* +1 for '-' */

CHAR_BIT 在 <limits.h> 中定义, 但是这个计算可能 有些过于保守了。它计算的是数字以八进制存储需要的字节数; 十进制的存储可 以保证使用同样或更少的字节数。

当格式串更复杂或者在运行前未知的时候, 预测缓冲区大小会变得跟重新实现  sprintf 一样困难, 而且会很容易出错。有一种最后防线的技术, 就是 fprintf()  向一块内存区或临时文件输出同样的内容, 然后检查 fprintf 的返回值或临时文件 的大小, 但请参见问题 19.14, 并提防写文件错误。

如果不能确保缓冲区足够大, 你就不能调用 sprintf(), 以防缓冲区溢出后改写 其它的内存区。如果格式串已知, 你可以用 %.Ns 控制 %s 扩展的长度, 或者使用 %.*s, 参见问题 12.9。

要避免溢出问题, 你可以使用限制长度的 sprintf() 版本, 即 snprintf()。 这样使用：

    snprintf(buf, bufsize, "You typed \"%s\"", answer);

snprintf() 在几个 stdio 库中已经提供好几年了, 包括 GNU 和 4.4bsd。 在 C99 中已经被标准化了。

作为一个额外的好处, C99 的 snprintf() 提供了预测任意 sprintf() 调用所需的 缓冲区大小的方法。C99 的 snprintf() 返回它可能放到缓冲区的字符数, 而它又 可以用 0 作为缓冲区大小进行调用。因此

	nch = snprintf(NULL, 0, fmtstring, /* 其它参数 */ );

这样的调用就可以预测出格式串扩展后所需要的字符数。

另一个 (非标准的) 选择是 asprintf() 函数, 在 bsd 和 GNU 的 C 库中都有提供, 它调用 malloc 为格式串分配空间, 并返回分配内存区的指针。这样使用:

	char *buf;
	asprintf(&buf, "%d = %s", 42, "forty-two");
	/* 现在, buf 指向含有格式串的 malloc 的内存 */
