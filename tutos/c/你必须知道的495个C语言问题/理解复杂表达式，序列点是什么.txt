序列点是一个时间点(在整个表达式全部计算完毕之后或在 ||、  &&、 ? : 或逗号 运算符处, 或在函数调用之前), 此刻尘埃落定, 所有的副作用都已确保结束。 ANSI/ISO C 标准这样描述:

    在上一个和下一个序列点之间, 一个对象所保存的值至多只能被表达式的 计算修改一次。而且前一个值只能用于决定将要保存的值。 

第二句话比较费解。它说在一个表达式中如果某个对象需要写入, 则在同一表达式中对该对象的访问应该只局限于直接用于计算将要 写入的值。这条规则有效地限制了只有能确保在修改之前才访问 变量的表达式为合法。例如 i = i+1 合法, 而 a[i] = i++ 则非法


为什么这样的代码:  a[i] = i++; 不能工作？

子表达式 i++ 有一个副作用,它会改变 i 的值 
由于 i 在同一表达式的其它地方被引用, 这会导致无定义的结果, 无从判断该引用(左边的 a[i] 中)是旧值还是新值。(注意, 尽管 在 K&R 中建议这类表达式的行为不确定, 但C标准却强烈声明它是无定义的