C 语言中的确任何非零值都都被看作真, 但这仅限于 ``输入", 也就是说, 仅限于需要布尔值的地方。内建操作符生成布尔值时, 可以保证为 1 或 0。 因此, 这样的测试

    if((a == b) == TRUE)

能如愿运行 (只要 TRUE 为 1), 但显然这很傻。 事实上, 跟 TRUE 和 FALSE 的 跟 TRUE 和 FALSE 的 显示比较都不合适, 因为有些库函数 (如 isupper(), isalpha() 等) 在成功时返 回非零值, 但不一定为1。 (再说, 如果你认为 ``if((a == b) == TRUE)" 比 ``if(a == b)" 好, 为什么就此打住呢？为什么不使用 ``if(((a == b) == TRUE) == TRUE)" 呢?) 一般规则是只在向布尔变量赋值或 函数参数中才使用 TRUE 和 FALSE (或类似的东西), 或者用于函数的返回值, 但决不用于比较。

预处理宏 TRUE 和 FALSE (当然还有 NULL) 只是用于增加代码可读性, 而不是因为其 值可能改变。(参见问题 5.3 和 5.8。)

尽管使用 TRUE 和 FALSE 这样的宏 (或者 YES 和 NO) 看上去更清楚, 布尔值和 定义在 C 语言中的复杂性让很多程序员觉得 TRUE 和 FALSE 宏不过更令人迷惑, 因而更喜欢使用 1 和 0。 