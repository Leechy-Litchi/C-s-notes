https://www.pianshen.com/article/3308605484/

“GNU，名称来自Gnu's Not Unix"的缩写，一个类UNIX的操作系统，由GNU计划推动，目标在于创建一个完全兼容于UNIX的自由软件环境。”
由于当时UNIX系统是商业软件，是收费的，而且有一部分源码是没有开放的，所以在1983年，理查德・斯托曼提出GNU计划，希望发展出一套完整的开放源代码操作系统来取代Unix，计划中的操作系统，名为GNU。
注意：linux并不是GNU计划的一部分。linux只是使用了许多GNU计划软件(包括GCC编译器，文本编译器等)。
1992年，Linux与其他GNU软件结合，完全自由的操作系统正式诞生。许多程序员参与了Linux的开发与修改，也经常将Linux当成开发GNU计划软件的平台。该操作系统往往被称为“GNU/Linux”或简称Linux。但Linux本身不属于GNU计划的一部份，GNU计划自己的内核Hurd依然在开发中，但直到2013年为止，都还没有稳定版本发布。
GNU计划采用了部分当时已经可自由使用的软件，例如TeX排版系统和X Window视窗系统等。不过GNU计划也开发了大批其他的自由软件，这些软件也被移植到其他操作系统平台上，例如Microsoft Windows、BSD家族、Solaris及Mac OS。
总结：GNU计划本来是为了开发一个自由系统来取代UNIX的，但是由于开发的内核hurd一直不怎么样，这个系统至今都没出稳定版本，然而GNU计划中开发的其他一些自由软件，比如GCC编译器，却非常的好，在移植到各大操作系统上一直广泛使用至今。


“ GCC（GNU Compiler Collection，GNU编译器套装），是一套由GNU开发的编程语言编译器。它是一套以GPL及LGPL许可证所发布的自由软件，也是GNU项目的关键部分，亦是自由的类Unix及苹果电脑Mac OS X 操作系统的标准编译器。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。
GCC原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC很快地扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，以及Go与其他语言。
后来因为LLVM、Clang的崛起，令GCC更快将开发语言转换为C++。
由于GCC已成为GNU系统的官方编译器（包括GNU/Linux家族），它也成为编译与创建其他操作系统的主要编译器，包括BSD家族、Mac OS X、NeXTSTEP与BeOS。
GCC通常是跨平台软件的编译器首选。GCC在所有平台上都使用同一个前端处理程序，产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。 

总结：mac之前的cocoa框架便是用GCC编译的，所以ios与mac os都是默认使用的GCC编译器(现在是clang与llvm，下面会有介绍）,android的系统层因为是linux内核，自然也是GCC编译的，但是android的app因为是运行在Dalvik虚拟机，所以用的不是GCC。windows的应用，大部分都是使用的vs系列的编译器，毕竟是windows自家的编译器，用到GCC的不多。


Clang
“ Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。
它的目标是提供一个GNU编译器套装（GCC）的替代品。 Clang项目包括Clang前端和Clang静态分析器等。
在2005年由苹果电脑发起，是LLVM编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。
Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右。FreeBSD 10将Clang/LLVM作为默认编译器.
测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。 

总结：GCC目前作为跨平台编译器来说它的兼容性无异是最强的，兼容最强肯定是以牺牲一定的性能为基础的，苹果为了提高性能，因此专门针对mac系统开发了专用的编译器clang与llvm，clang用于编译器前段，llvm用于后端。


LLVM
“ LLVM，它是一个编译器的基础建设，以C++写成。它是为了任意一种编程语言写成的程序，利用虚拟技术，创造出编译时期，链结时期，运行时期以及“闲置时期”的优化。
在Xcode4之后，苹果将Xcode的默认编译器变成了LLVM，为什么呢？
LLVM历史
	Apple（包括中后期的NeXT） 一直使用GCC作为官方的编译器。GCC作为开源世界的编译器标准一直做得不错，但Apple对编译工具会提出更高的要求。
	一方面，是Apple对Objective-C语言（甚至后来对C语言）新增很多特性，但GCC开发者并不买Apple的帐――不给实现，因此索性后来两者分成两条分支分别开发，这也造成Apple的编译器版本远落后于GCC的官方版本。
	另一方面，GCC的代码耦合度太高，不好独立，而且越是后期的版本，代码质量越差，但Apple想做的很多功能（比如更好的IDE支持）需要模块化的方式来调用GCC，但GCC一直不给做，从根本上限制了LLVM-GCC的开发。 
所以，这种不和让Apple一直在寻找一个高效的、模块化的、协议更放松的开源替代品，于是Apple请来了编译器高材生Chris Lattner， LLVM就这样产生了。

Clang历史
	Apple吸收Chris Lattner的目的要比改进GCC代码优化宏大得多――GCC系统庞大而笨重，而Apple大量使用的Objective-C在GCC中优先级很低。
	此外GCC作为一个纯粹的编译系统，与IDE配合得很差。加之许可证方面的要求，Apple无法使用LLVM 继续改进GCC的代码质量。
	于是，Apple决定从零开始写 C、C++、Objective-C语言的前端 Clang，完全替代掉GCC。
	正像名字所写的那样，Clang只支持C，C++和Objective-C三种C家族语言。
	2007年开始开发，C编译器最早完成，而由于Objective-C相对简单，只是C语言的一个简单扩展，很多情况下甚至可以等价地改写为C语言对Objective-C运行库的函数调用，因此在2009年时，已经完全可以用于生产环境。C++的支持也热火朝天地进行着。  
更详细的原因：
Xcode编译器介绍: http://www.cnblogs.com/ydhliphonedev/archive/2012/08/29/2661726.html

总结：因为GCC的编译器已经慢慢无法满足苹果的需求，因此，苹果开发了Clang与LLVM来完全取代GCC，Xcode4之后，苹果的默认编译器已经是LLVM了。Clang作为编译器前端，LLVM作为编译器后端。


编译器相关知识
编译器的前后端到底是什么东西呢
1.c->预处理（CPP,不知道是不是C Program Preprocessor的简称）->编译（GCC）->汇编（GAS）->链接（LD）->1（C代码生成程序过程.jpg）
通过编译原理可知（代码编译过程.jpg）
		符号表管理（与下面的除第一个外的项目都有双向箭头）
源程序->词法分析->语法分析->语义分析->中间代码生成->优化->目标代码生成->目标代码
		错误诊查处理（与上面的除第一个外的项目都有双向箭头）
实际GCC的处理更复杂点，但本质上是一样的

并没有一个统一的gcc执行程序能够处理如此多的前端和后端，每个语言的编译器都是一个独立的程序（如C语言的编译器是gcc，C++的编译器是g++），而不同的后端也要对应不同的可执行程序。你可以下载单独的一份GCC源代码，通过不同的configure来生成自己需要的编译器。
前端的主要功能是产生一个可供后端处理的语法树，而语法树结构实际上很难与处理器架构脱钩，这些都是编译器应用中需要解决的问题。

GCC强大的真正原因是什么？是因为它支持了众多的前端和后端吗？这些都不过是一个表象而已。
GCC是一款真正自由的编译器，我们可以随时把代码拿过来修改以实现自己需要的功能。
如果你的硬件平台增加了一些指令，而普通的编译器并不能产生这些指令怎么办？
在GCC后端添加这些指令吧。
如果你觉得C语言用的不太顺手，想给它添加一些功能怎么办？
修改GCC的前端吧。
因为有了GCC，我们才拥有这些自由，以及迅速实现自己想法的能力，而这些才是GCC强大背后的基础。