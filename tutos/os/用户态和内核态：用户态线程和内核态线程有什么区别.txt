https://blog.csdn.net/qq_41489540/article/details/109261692
什么是用户态和内核态
Kernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：
    内核空间（Kernal Space），这个空间只有内核程序可以访问；
    用户空间（User Space），这部分内存专门给应用程序使用。

用户态和内核态
用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（User Mode） 执行。内核空间中的代码可以访问所有内存，我们称这些程序在内核态（Kernal Mode） 执行。

系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。

发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。

应用程序启动后会在内存中创建一个执行副本，这就是进程。Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。

程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。

一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。


用户态线程
也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。
优势
    管理开销小：创建、销毁不需要系统调用。
    切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。
缺点
    与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。
    线程间协作成本高：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。
    无法利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。
    操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。


内核态线程
也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。
优势
    可以利用多核 CPU 优势：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。
    操作系统级优化：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。
缺点
    创建成本高：创建的时候需要系统调用，也就是切换到内核态。
    扩展性差：由一个内核程序管理，不可能数量太多。
    切换成本较高：切换的时候，也同样存在需要内核操作，需要切换内核态。

用户态线程和内核态线程之间的映射关系
如果这个进程想要执行下面的某一个线程，应该如何做呢
比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 CPU 的执行资源。

如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。
这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。
无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。

因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了下面 4 种可能的关系：
多对一（Many to One）
多线程复用一个内核态线程。
程序是存储在内存中的指令,用户态线程可以准备好程序让内核态线程执行
 一对一（One to One）
为每个用户态的线程分配一个单独的内核态线程,Windows NT 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。
多对多(Many To Many)
n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。
一种可行的策略是将 m 设置为核数。
这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。
两层设计(Two Level)
多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。

用户态线程和内核态线程的区别
用户态线程工作在用户空间，内核态线程工作在内核空间。
用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。
内核线程由内核维护，由操作系统调度。

用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。
内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。
创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。






